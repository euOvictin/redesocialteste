const fc = require('fast-check');
const authService = require('./authService');
const jwt = require('jsonwebtoken');
const config = require('../config');

describe('AuthService - Property-Based Tests', () => {
  /**
   * Feature: rede-social-brasileira
   * Property 3: Autenticação com credenciais válidas retorna JWT
   * **Validates: Requirements 1.3**
   * 
   * Para qualquer usuário registrado com credenciais corretas,
   * autenticação deve retornar token JWT válido por 24 horas
   */
  describe('Property 3: Autenticação com credenciais válidas retorna JWT', () => {
    it('should generate valid JWT tokens for any valid user credentials', () => {
      fc.assert(
        fc.property(
          // Geradores de dados válidos
          fc.uuid(), // userId
          fc.emailAddress(), // email
          (userId, email) => {
            // Gerar tokens
            const tokens = authService.generateTokens(userId, email);

            // Verificações
            expect(tokens).toHaveProperty('accessToken');
            expect(tokens).toHaveProperty('refreshToken');
            expect(tokens).toHaveProperty('expiresIn');
            expect(tokens).toHaveProperty('tokenType', 'Bearer');

            // Verificar que o access token é válido
            const decodedAccess = jwt.verify(tokens.accessToken, config.jwt.secret);
            expect(decodedAccess.userId).toBe(userId);
            expect(decodedAccess.email).toBe(email);
            expect(decodedAccess).toHaveProperty('iat'); // issued at
            expect(decodedAccess).toHaveProperty('exp'); // expiration

            // Verificar que o refresh token é válido
            const decodedRefresh = jwt.verify(tokens.refreshToken, config.jwt.secret);
            expect(decodedRefresh.userId).toBe(userId);
            expect(decodedRefresh).toHaveProperty('iat');
            expect(decodedRefresh).toHaveProperty('exp');

            // Verificar que o token expira em 24 horas (aproximadamente)
            const expirationTime = decodedAccess.exp - decodedAccess.iat;
            const expectedExpiration = 24 * 60 * 60; // 24 horas em segundos
            expect(expirationTime).toBe(expectedExpiration);

            // Verificar que o token pode ser usado para autenticação
            const verified = authService.verifyToken(tokens.accessToken);
            expect(verified.userId).toBe(userId);
            expect(verified.email).toBe(email);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should generate unique tokens for different users', () => {
      fc.assert(
        fc.property(
          fc.uuid(),
          fc.emailAddress(),
          fc.uuid(),
          fc.emailAddress(),
          (userId1, email1, userId2, email2) => {
            // Garantir que os usuários são diferentes
            fc.pre(userId1 !== userId2 || email1 !== email2);

            const tokens1 = authService.generateTokens(userId1, email1);
            const tokens2 = authService.generateTokens(userId2, email2);

            // Tokens devem ser diferentes
            expect(tokens1.accessToken).not.toBe(tokens2.accessToken);
            expect(tokens1.refreshToken).not.toBe(tokens2.refreshToken);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should verify any valid token generated by the service', () => {
      fc.assert(
        fc.property(
          fc.uuid(),
          fc.emailAddress(),
          (userId, email) => {
            const token = authService.generateAccessToken({ userId, email });
            const decoded = authService.verifyToken(token);

            expect(decoded.userId).toBe(userId);
            expect(decoded.email).toBe(email);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should correctly extract token from any valid Bearer header', () => {
      fc.assert(
        fc.property(
          fc.stringMatching(/^[A-Za-z0-9._-]{10,500}$/), // token JWT-like (alfanumérico com . _ -)
          (token) => {
            const authHeader = `Bearer ${token}`;
            const extracted = authService.extractTokenFromHeader(authHeader);

            expect(extracted).toBe(token);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should return null for any malformed authorization header', () => {
      fc.assert(
        fc.property(
          fc.oneof(
            fc.constant(undefined),
            fc.constant(null),
            fc.constant(''),
            fc.string({ minLength: 1, maxLength: 100 }).filter(s => !s.startsWith('Bearer ')),
            fc.string({ minLength: 1, maxLength: 100 }).map(s => `Basic ${s}`),
            fc.constant('Bearer') // sem token
          ),
          (authHeader) => {
            const extracted = authService.extractTokenFromHeader(authHeader);
            expect(extracted).toBeNull();
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should reject any token with invalid signature', () => {
      fc.assert(
        fc.property(
          fc.uuid(),
          fc.emailAddress(),
          fc.string({ minLength: 10, maxLength: 50 }), // secret diferente
          (userId, email, wrongSecret) => {
            // Garantir que o secret é diferente
            fc.pre(wrongSecret !== config.jwt.secret);

            // Criar token com secret errado
            const invalidToken = jwt.sign({ userId, email }, wrongSecret);

            // Deve lançar erro ao verificar
            expect(() => authService.verifyToken(invalidToken)).toThrow();
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should maintain token validity for the entire expiration period', () => {
      fc.assert(
        fc.property(
          fc.uuid(),
          fc.emailAddress(),
          (userId, email) => {
            const token = authService.generateAccessToken({ userId, email });
            const decoded = jwt.decode(token);

            // Verificar que o token ainda não expirou
            const now = Math.floor(Date.now() / 1000);
            expect(decoded.exp).toBeGreaterThan(now);

            // Verificar que o token foi emitido no passado recente
            expect(decoded.iat).toBeLessThanOrEqual(now);

            // Verificar que o token é válido agora
            const verified = authService.verifyToken(token);
            expect(verified.userId).toBe(userId);
          }
        ),
        { numRuns: 100 }
      );
    });
  });
});
